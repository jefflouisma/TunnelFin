using FluentAssertions;
using System.Buffers.Binary;
using TunnelFin.Networking.IPv8;
using Xunit;

namespace TunnelFin.Tests.Networking;

/// <summary>
/// Byte-level IPv8 message verification tests.
/// Verifies C# serialization produces byte-identical output to Python struct.pack.
/// Uses hex test vectors from py-ipv8 for cross-language compatibility (FR-048).
/// </summary>
public class IPv8WireFormatTests
{
    [Fact]
    public void BigEndian_UInt32_Should_Match_Python_StructPack()
    {
        // Python: struct.pack(">I", 0x12345678) produces [0x12, 0x34, 0x56, 0x78]
        // Arrange
        var buffer = new byte[4];
        uint value = 0x12345678;

        // Act
        BinaryPrimitives.WriteUInt32BigEndian(buffer, value);

        // Assert
        buffer.Should().Equal(new byte[] { 0x12, 0x34, 0x56, 0x78 },
            "C# big-endian serialization must match Python struct.pack('>I')");
    }

    [Fact]
    public void BigEndian_UInt16_Should_Match_Python_StructPack()
    {
        // Python: struct.pack(">H", 0x1234) produces [0x12, 0x34]
        // Arrange
        var buffer = new byte[2];
        ushort value = 0x1234;

        // Act
        BinaryPrimitives.WriteUInt16BigEndian(buffer, value);

        // Assert
        buffer.Should().Equal(new byte[] { 0x12, 0x34 },
            "C# big-endian serialization must match Python struct.pack('>H')");
    }

    [Fact]
    public void BigEndian_UInt64_Should_Match_Python_StructPack()
    {
        // Python: struct.pack(">Q", 0x123456789ABCDEF0) produces [0x12, 0x34, ..., 0xF0]
        // Arrange
        var buffer = new byte[8];
        ulong value = 0x123456789ABCDEF0;

        // Act
        BinaryPrimitives.WriteUInt64BigEndian(buffer, value);

        // Assert
        buffer.Should().Equal(new byte[] { 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0 },
            "C# big-endian serialization must match Python struct.pack('>Q')");
    }

    [Fact]
    public void Boolean_Should_Serialize_As_Single_Byte()
    {
        // Python: struct.pack("?", True) produces [0x01], struct.pack("?", False) produces [0x00]
        // Arrange
        var bufferTrue = new byte[1];
        var bufferFalse = new byte[1];

        // Act
        bufferTrue[0] = true ? (byte)1 : (byte)0;
        bufferFalse[0] = false ? (byte)1 : (byte)0;

        // Assert
        bufferTrue.Should().Equal(new byte[] { 0x01 }, "True must serialize as 0x01");
        bufferFalse.Should().Equal(new byte[] { 0x00 }, "False must serialize as 0x00");
    }

    [Fact]
    public void CircuitID_Should_Serialize_As_BigEndian_UInt32()
    {
        // Circuit IDs are 4-byte big-endian unsigned integers per ipv8-wire-format.md
        // Arrange
        var buffer = new byte[4];
        uint circuitId = 0xABCD1234;

        // Act
        BinaryPrimitives.WriteUInt32BigEndian(buffer, circuitId);

        // Assert
        buffer.Should().Equal(new byte[] { 0xAB, 0xCD, 0x12, 0x34 },
            "Circuit ID must be serialized as big-endian uint32");
    }

    [Fact]
    public void PortNumber_Should_Serialize_As_BigEndian_UInt16()
    {
        // Port numbers are 2-byte big-endian unsigned shorts per ipv8-wire-format.md
        // Arrange
        var buffer = new byte[2];
        ushort port = 8080;

        // Act
        BinaryPrimitives.WriteUInt16BigEndian(buffer, port);

        // Assert
        buffer.Should().Equal(new byte[] { 0x1F, 0x90 },
            "Port number must be serialized as big-endian uint16");
    }

    [Fact]
    public void VariableLength_Field_Should_Have_TwoByte_BigEndian_Length_Prefix()
    {
        // Variable-length fields use 2-byte big-endian length prefix per ipv8-wire-format.md
        // Arrange
        var data = new byte[] { 0xAA, 0xBB, 0xCC };
        var buffer = new byte[2 + data.Length];

        // Act
        BinaryPrimitives.WriteUInt16BigEndian(buffer.AsSpan(0), (ushort)data.Length);
        data.CopyTo(buffer, 2);

        // Assert
        buffer.Should().Equal(new byte[] { 0x00, 0x03, 0xAA, 0xBB, 0xCC },
            "Variable-length field must have 2-byte big-endian length prefix");
    }

    [Fact]
    public void CreateMessage_Should_Match_Python_Test_Vector()
    {
        // Test vector from ipv8_test_vectors.json generated by py-ipv8
        // CREATE message format: I H varlenH varlenH (circuit_id, identifier, node_key, ephemeral_key)

        // Arrange - values from test vector
        uint circuitId = 0x12345678;
        ushort identifier = 0xABCD;
        byte[] nodeKey = new byte[32];
        byte[] ephemeralKey = new byte[32];

        // Fill keys with test data (0x00-0x1F for node key, 0x20-0x3F for ephemeral key)
        for (int i = 0; i < 32; i++)
        {
            nodeKey[i] = (byte)i;
            ephemeralKey[i] = (byte)(i + 32);
        }

        // Expected hex from py-ipv8 (74 bytes total)
        string expectedHex = "12345678abcd0020000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f0020202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f";

        // Act
        var serialized = CircuitMessage.SerializeCreate(circuitId, identifier, nodeKey, ephemeralKey);
        var actualHex = Convert.ToHexString(serialized).ToLower();

        // Assert
        actualHex.Should().Be(expectedHex, "CREATE message must match py-ipv8 byte-for-byte");
        serialized.Length.Should().Be(74, "CREATE message should be 74 bytes (4+2+2+32+2+32)");
    }
}

